<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M/M/c/K 모델 시각화 및 성능 분석 도구</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        canvas { max-width: 100%; height: auto; margin-bottom: 20px; }
        input, button, select { margin: 10px 0; }
    </style>
</head>
<body>
<div class="container">
    <h1>M/M/c/K 모델 분석 결과 및 성능 분석 도구</h1>
    <div>
        <label for="nValue">n 값 (대기 중인 고객 수):</label>
        <input type="number" id="nValue" min="1" max="400" value="10">
        <button onclick="calculateWaitTime()">대기 시간 계산</button>
    </div>
    <div>
        <label for="cValue">c 값 (서버 수):</label>
        <select id="cValue" onchange="updateServiceCompletionTime()">
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
        </select>
    </div>
    <div>
        <label for="totalCustomers">총 고객 수:</label>
        <input type="number" id="totalCustomers" min="1" max="1000" value="100">
        <button onclick="updateServiceCompletionTime()">서비스 종료 시간 계산</button>
    </div>
    <div id="waitTimeResult"></div>
    <div id="serviceCompletionTimeResult"></div>
    <canvas id="resultsChart"></canvas>
    <canvas id="waitTimeChart"></canvas>
    <canvas id="serviceCompletionTimeChart"></canvas>
    <div id="resultsSummary"></div>
</div>

<script>
    // M/M/c/K 모델 계산 함수
    function calculateMMCK(lambda, mu, c, K) {
        const rho = lambda / (c * mu);
        let p0 = 0;

        // p0 계산
        for (let n = 0; n <= c; n++) {
            p0 += Math.pow(c * rho, n) / factorial(n);
        }

        if (rho !== 1) {
            p0 += Math.pow(c * rho, c) / factorial(c) * (1 - Math.pow(rho, K - c + 1)) / (1 - rho);
        } else {
            // rho = 1인 경우의 특수 처리
            p0 += Math.pow(c * rho, c) / factorial(c) * (K - c + 1);
        }

        p0 = 1 / p0;

        // pb (blocking probability) 계산
        const pb = Math.pow(c * rho, K) * p0 / (factorial(c) * Math.pow(c, K - c));

        // lq (대기열 길이) 계산
        let lq;
        if (rho !== 1) {
            lq = p0 * Math.pow(c * rho, c) * rho / (factorial(c) * Math.pow(1 - rho, 2));
            lq *= (1 - Math.pow(rho, K - c + 1) - (1 - rho) * (K - c + 1) * Math.pow(rho, K - c));
        } else {
            lq = p0 * Math.pow(c * rho, c) * (K - c) * (K - c + 1) / (2 * factorial(c));
        }

        // ls, wq, ws 계산
        const ls = lq + c * rho * (1 - pb);
        const wq = lq / (lambda * (1 - pb));
        const ws = wq + 1 / mu;

        return { pb, lq, ls, wq, ws };
    }

    function factorial(n) {
        if (n === 0 || n === 1) return 1;
        return n * factorial(n - 1);
    }

    // 대기 시간 계산 함수
    function calculateExpectedWaitTime(n, c, mu) {
        if (n <= c) return 0;
        return ((n - c) / c) * (1 / mu);
    }

    // 서비스 종료 시간 계산 함수
    function calculateServiceCompletionTime(n, c, mu) {
        return Math.ceil(n / c) * (1 / mu);
    }

    // 모델 파라미터
    const lambda = 4;  // 도착률 (명/분)
    const mu = 6;      // 서비스 속도 (명/분)
    let c = 2;         // 서버 수 (기본값)
    const K = 400;     // 최대 고객 수

    // 결과 계산
    let results = calculateMMCK(lambda, mu, c, K);

    // 결과 차트 생성
    const ctx = document.getElementById('resultsChart').getContext('2d');
    const resultsChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['차단 확률 (Pb)', '평균 대기 고객 수 (Lq)', '평균 시스템 내 고객 수 (Ls)', '평균 대기 시간 (Wq)', '평균 체류 시간 (Ws)'],
            datasets: [{
                label: 'M/M/c/K 모델 결과',
                data: [results.pb, results.lq, results.ls, results.wq, results.ws],
                backgroundColor: [
                    'rgba(255, 99, 132, 0.2)',
                    'rgba(54, 162, 235, 0.2)',
                    'rgba(255, 206, 86, 0.2)',
                    'rgba(75, 192, 192, 0.2)',
                    'rgba(153, 102, 255, 0.2)'
                ],
                borderColor: [
                    'rgba(255, 99, 132, 1)',
                    'rgba(54, 162, 235, 1)',
                    'rgba(255, 206, 86, 1)',
                    'rgba(75, 192, 192, 1)',
                    'rgba(153, 102, 255, 1)'
                ],
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                y: {
                    beginAtZero: true
                }
            },
            responsive: true,
            plugins: {
                legend: {
                    position: 'top',
                },
                title: {
                    display: true,
                    text: 'M/M/c/K 모델 분석 결과'
                }
            }
        }
    });

    // 결과 요약 텍스트 생성 함수
    function updateResultsSummary() {
        const summaryElement = document.getElementById('resultsSummary');
        summaryElement.innerHTML = `
                <h2>결과 요약:</h2>
                <p>차단 확률 (Pb): ${results.pb.toExponential(2)}</p>
                <p>평균 대기 고객 수 (Lq): ${results.lq.toFixed(3)}명</p>
                <p>평균 시스템 내 고객 수 (Ls): ${results.ls.toFixed(2)}명</p>
                <p>평균 대기 시간 (Wq): ${(results.wq * 60).toFixed(1)}초</p>
                <p>평균 체류 시간 (Ws): ${(results.ws * 60).toFixed(1)}초</p>
            `;
    }

    // 대기 시간 계산 및 차트 업데이트 함수
    function calculateWaitTime() {
        const nValue = parseInt(document.getElementById('nValue').value);
        const waitTime = calculateExpectedWaitTime(nValue, c, mu);

        document.getElementById('waitTimeResult').innerHTML = `
                <p>n = ${nValue}일 때 예상 대기 시간: ${(waitTime * 60).toFixed(1)}초</p>
            `;

        // 대기 시간 차트 업데이트
        updateWaitTimeChart();
    }

    // 대기 시간 차트 생성 및 업데이트 함수
    let waitTimeChart;
    function updateWaitTimeChart() {
        const nValues = Array.from({length: 30}, (_, i) => i + 1);
        const waitTimes = nValues.map(n => calculateExpectedWaitTime(n, c, mu) * 60); // 초 단위로 변환

        if (waitTimeChart) {
            waitTimeChart.destroy();
        }

        const ctx = document.getElementById('waitTimeChart').getContext('2d');
        waitTimeChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: nValues,
                datasets: [{
                    label: '예상 대기 시간 (초)',
                    data: waitTimes,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '대기 시간 (초)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '대기 중인 고객 수 (n)'
                        }
                    }
                },
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: '대기 중인 고객 수에 따른 예상 대기 시간'
                    }
                }
            }
        });
    }

    // 서비스 종료 시간 계산 및 차트 업데이트 함수
    let serviceCompletionTimeChart;
    function updateServiceCompletionTime() {
        c = parseInt(document.getElementById('cValue').value);
        const totalCustomers = parseInt(document.getElementById('totalCustomers').value);
        results = calculateMMCK(lambda, mu, c, K);
        updateResultsSummary();
        resultsChart.data.datasets[0].data = [results.pb, results.lq, results.ls, results.wq, results.ws];
        resultsChart.update();

        const cValues = [1, 2, 3, 4, 5];
        const completionTimes = cValues.map(c => calculateServiceCompletionTime(totalCustomers, c, mu) * 60); // 초 단위로 변환

        document.getElementById('serviceCompletionTimeResult').innerHTML = `
                <p>서버 수 c = ${c}, 총 고객 수 = ${totalCustomers}일 때 서비스 종료 시간: ${completionTimes[c-1].toFixed(1)}초</p>
            `;

        if (serviceCompletionTimeChart) {
            serviceCompletionTimeChart.destroy();
        }

        const ctx = document.getElementById('serviceCompletionTimeChart').getContext('2d');
        serviceCompletionTimeChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: cValues,
                datasets: [{
                    label: '서비스 종료 시간 (초)',
                    data: completionTimes,
                    borderColor: 'rgba(255, 159, 64, 1)',
                    tension: 0.1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '서비스 종료 시간 (초)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '서버 수 (c)'
                        }
                    }
                },
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: '서버 수에 따른 서비스 종료 시간'
                    }
                }
            }
        });

        // 대기 시간 차트도 함께 업데이트
        updateWaitTimeChart();
    }

    // 초기 차트 생성
    updateWaitTimeChart();
    updateServiceCompletionTime();
</script>
</body>
</html>